{"ast":null,"code":"// TODO: Implement construct and setter in nested Schemas\n// TODO: Make a self proxy implementer\n// TODO: Refactor to use Schema Methods\nimport Schema from './schema';\nimport ERRORS from './errors';\n/**\n * Looks at the schema param and validate\n * @param {any} schema\n * @returns\n */\n\nconst checkSchema = schema => {\n  if (Object.keys(schema).length === 0) throw ERRORS.emtpy_param('Schema param');\n  if (!(schema instanceof Schema)) throw ERRORS.not_valid_typo('param', 'Schema Object');\n  return schema;\n};\n/**\n * Checks if the param given are not empty and\n * is an Object type\n * @param {any} param\n * @returns\n */\n\n\nconst checkParams = param => {\n  if (!param) throw ERRORS.emtpy_param('Data', 'Constructor input cannot be emtpy');\n  if (param.constructor !== Object) throw ERRORS.not_valid_typo('Param', 'Object');\n  return param;\n};\n/**\n * Creates a Handler to use in a Proxy constructor\n * @param {Validator} validator\n * @returns Handler Object\n */\n\n\nconst createHandler = validator => {\n  const setter = {\n    set(target, key, value) {\n      validator.attributeInSchema(key);\n      if (value === undefined) return true;\n\n      if (target[key] === undefined || target[key].constructor !== Object) {\n        Object.assign(target, {\n          [key]: validator.validateValue(value, key)\n        });\n      }\n\n      Object.assign(target, {\n        [key]: validator.validateValue(value, key)\n      });\n      return true;\n    }\n\n  };\n  const construct = {\n    construct(Target, args) {\n      const obj = checkParams(args[0]);\n      const schema = { ...validator.schema\n      };\n      Object.keys(schema).forEach(key => {\n        if (schema[key].required && (!(key in obj) || obj[key] === undefined)) {\n          throw ERRORS.att_required(key);\n        }\n      });\n      Object.keys(obj).forEach(key => {\n        if (obj[key].constructor === Object && Object.keys(obj[key]).length > 0) {\n          validator.attributeInSchema(key);\n          return;\n        }\n\n        validator.validateValue(obj[key], key);\n      });\n      return new Proxy(new Target(...args), setter);\n    }\n\n  };\n  return construct;\n};\n/**\n * Validate the given data against the schema given as argument\n * in the constructor\n * @class Validator\n */\n\n\nclass Validator {\n  /**\n   * Creates an instance of Validator.\n   * @param {Schema} [schema]\n   * @memberof Validator\n   */\n  constructor() {\n    let schema = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.schema = checkSchema(schema);\n  }\n  /**\n   * Validate that the property are in the schema\n   * @param {any} key\n   * @memberof Validator\n   */\n\n\n  attributeInSchema(key) {\n    if (!(key in this.schema)) {\n      throw ERRORS.att_not_valid(key);\n    }\n  }\n  /**\n   * Check if the value has the same type that the Schema type\n   * and looks if are include in the given array in the Schema enum property\n   * @param {any} key\n   * @param {any} input\n   * @memberof Validator this.schema[key].hasOwnProperty('enum')\n   */\n\n\n  valueInEnum(key, input) {\n    if (!('enum' in this.schema[key])) {\n      throw ERRORS.att_not_valid(key, `${key} has not attribute 'enum'`);\n    }\n\n    this.validateType(key, input);\n\n    if (!this.schema[key].enum.includes(input)) {\n      throw ERRORS.not_in_enum(key, input, this.schema[key].enum);\n    }\n\n    return input;\n  }\n  /**\n   * Look if the property is required\n   * @param {any} key\n   * @returns Boolean\n   * @memberof Validator\n   */\n\n\n  valueRequired(key) {\n    return this.schema[key].required;\n  }\n  /**\n   * Looks if property could be editable\n   * @param {any} key\n   * @returns Boolean\n   * @memberof Validator\n   */\n\n\n  valueEditable(key) {\n    return this.schema[key].editable;\n  }\n  /**\n   * Looks if enum property are in attribute\n   * @param {any} key\n   * @returns Boolean\n   * @memberof Validator\n   */\n\n\n  isEnumInAttribute(key) {\n    return 'enum' in this.schema[key];\n  }\n  /**\n  * Return every attribute key who could be\n  * editable\n  * @returns Array\n  * @memberof Validator\n  */\n\n\n  getEditables() {\n    return Object.keys(this.schema).reduce((accum, key) => {\n      if (this.schema[key].editable) {\n        accum.concat(key);\n      }\n\n      return accum;\n    }, []);\n  }\n  /**\n   * Returns true if the attribute with the given key is Object type\n   * @param {any} key\n   * @returns Boolean\n   * @memberof Validator\n   */\n\n\n  valueIsObject(key) {\n    return this.schema[key].type === Object;\n  }\n  /**\n   * Validate the value give it against\n   * rules specified in Schema object\n   * @param {any} value\n   * @param {any} key\n   * @param {Boolean} isConstruct\n   * @returns value\n   * @memberof Validator\n   */\n\n\n  validateValue(value, key) {\n    this.attributeInSchema(key);\n    /**\n     * TODO: La validacion debe ser mas inteligente\n     * Es necesario verificar si es un Array, no este vacio\n     * Si es un string, no este vacio\n     * o Undefined para ambos casos\n     * Esto, cuando son requeridos.\n     */\n\n    if (this.valueRequired(key) && (value === undefined || value.length === 0)) {\n      throw ERRORS.att_required(key);\n    }\n\n    this.validateType(key, value);\n\n    if (this.isEnumInAttribute(key)) {\n      this.valueInEnum(key, value);\n    }\n\n    return value;\n  }\n  /**\n   * Validate the value against the typo given in the schema for the attribute\n   * @param {any} key\n   * @param {any} input\n   * @memberof Validator\n   */\n\n\n  validateType(key, input) {\n    if (this.schema.isNestedSchema(key)) return input;\n\n    if (input.constructor !== this.schema[key].type && Object.keys(this.schema[key]).includes('type')) {\n      const type = this.schema[key].type.toString().match(/[A-Z][a-z]+/g)[0];\n      throw ERRORS.not_valid_typo(key, type);\n    }\n\n    return input;\n  }\n  /**\n   * Create and apply a proxy to an object using the current\n   * schema when the validator was created\n   * @param {any} object\n   * @returns newObjectWithProxy\n   * @memberof Validator\n   */\n\n\n  generateProxy(object) {\n    if (!object) throw ERRORS.emtpy_param('Object or Class');\n    const handler = createHandler(this);\n    const withProxy = new Proxy(object, handler);\n    return withProxy;\n  }\n\n}\n\nexport default Validator;","map":{"version":3,"names":["Schema","ERRORS","checkSchema","schema","Object","keys","length","emtpy_param","not_valid_typo","checkParams","param","constructor","createHandler","validator","setter","set","target","key","value","attributeInSchema","undefined","assign","validateValue","construct","Target","args","obj","forEach","required","att_required","Proxy","Validator","att_not_valid","valueInEnum","input","validateType","enum","includes","not_in_enum","valueRequired","valueEditable","editable","isEnumInAttribute","getEditables","reduce","accum","concat","valueIsObject","type","isNestedSchema","toString","match","generateProxy","object","handler","withProxy"],"sources":["/Users/mac/Desktop/sky/skyalert-New/src/utils/validator.js"],"sourcesContent":["// TODO: Implement construct and setter in nested Schemas\n// TODO: Make a self proxy implementer\n// TODO: Refactor to use Schema Methods\n\nimport Schema from './schema';\nimport ERRORS from './errors';\n\n/**\n * Looks at the schema param and validate\n * @param {any} schema\n * @returns\n */\nconst checkSchema = (schema) => {\n  if (Object.keys(schema).length === 0) throw ERRORS.emtpy_param('Schema param');\n  if (!(schema instanceof Schema)) throw ERRORS.not_valid_typo('param', 'Schema Object');\n\n  return schema;\n};\n\n/**\n * Checks if the param given are not empty and\n * is an Object type\n * @param {any} param\n * @returns\n */\nconst checkParams = (param) => {\n  if (!param) throw ERRORS.emtpy_param('Data', 'Constructor input cannot be emtpy');\n  if (param.constructor !== Object) throw ERRORS.not_valid_typo('Param', 'Object');\n\n  return param;\n};\n\n/**\n * Creates a Handler to use in a Proxy constructor\n * @param {Validator} validator\n * @returns Handler Object\n */\nconst createHandler = (validator) => {\n  const setter = {\n    set(target, key, value) {\n      validator.attributeInSchema(key);\n\n      if (value === undefined) return true;\n      if (target[key] === undefined || target[key].constructor !== Object) {\n        Object.assign(target, { [key]: validator.validateValue(value, key) });\n      }\n\n      Object.assign(target, { [key]: validator.validateValue(value, key) });\n\n      return true;\n    },\n  };\n\n  const construct = {\n    construct(Target, args) {\n      const obj = checkParams(args[0]);\n\n      const schema = { ...validator.schema };\n\n      Object.keys(schema).forEach((key) => {\n        if (schema[key].required && (!(key in obj) || obj[key] === undefined)) {\n          throw ERRORS.att_required(key);\n        }\n      });\n\n      Object.keys(obj).forEach((key) => {\n        if (obj[key].constructor === Object && Object.keys(obj[key]).length > 0) {\n          validator.attributeInSchema(key);\n          return;\n        }\n\n        validator.validateValue(obj[key], key);\n      });\n\n      return new Proxy(new Target(...args), setter);\n    },\n  };\n\n  return construct;\n};\n\n/**\n * Validate the given data against the schema given as argument\n * in the constructor\n * @class Validator\n */\nclass Validator {\n  /**\n   * Creates an instance of Validator.\n   * @param {Schema} [schema]\n   * @memberof Validator\n   */\n  constructor(schema = {}) {\n    this.schema = checkSchema(schema);\n  }\n\n  /**\n   * Validate that the property are in the schema\n   * @param {any} key\n   * @memberof Validator\n   */\n  attributeInSchema(key) {\n    if (!(key in this.schema)) {\n      throw ERRORS.att_not_valid(key);\n    }\n  }\n\n  /**\n   * Check if the value has the same type that the Schema type\n   * and looks if are include in the given array in the Schema enum property\n   * @param {any} key\n   * @param {any} input\n   * @memberof Validator this.schema[key].hasOwnProperty('enum')\n   */\n  valueInEnum(key, input) {\n    if (!('enum' in this.schema[key])) {\n      throw ERRORS.att_not_valid(key, `${key} has not attribute 'enum'`);\n    }\n\n    this.validateType(key, input);\n\n    if (!this.schema[key].enum.includes(input)) {\n      throw ERRORS.not_in_enum(key, input, this.schema[key].enum);\n    }\n\n    return input;\n  }\n\n  /**\n   * Look if the property is required\n   * @param {any} key\n   * @returns Boolean\n   * @memberof Validator\n   */\n  valueRequired(key) {\n    return this.schema[key].required;\n  }\n\n  /**\n   * Looks if property could be editable\n   * @param {any} key\n   * @returns Boolean\n   * @memberof Validator\n   */\n  valueEditable(key) {\n    return this.schema[key].editable;\n  }\n\n  /**\n   * Looks if enum property are in attribute\n   * @param {any} key\n   * @returns Boolean\n   * @memberof Validator\n   */\n  isEnumInAttribute(key) {\n    return ('enum' in this.schema[key]);\n  }\n\n  /**\n * Return every attribute key who could be\n * editable\n * @returns Array\n * @memberof Validator\n */\n  getEditables() {\n    return Object.keys(this.schema).reduce((accum, key) => {\n      if (this.schema[key].editable) {\n        accum.concat(key);\n      }\n\n      return accum;\n    }, []);\n  }\n\n  /**\n   * Returns true if the attribute with the given key is Object type\n   * @param {any} key\n   * @returns Boolean\n   * @memberof Validator\n   */\n  valueIsObject(key) {\n    return (this.schema[key].type === Object);\n  }\n\n  /**\n   * Validate the value give it against\n   * rules specified in Schema object\n   * @param {any} value\n   * @param {any} key\n   * @param {Boolean} isConstruct\n   * @returns value\n   * @memberof Validator\n   */\n  validateValue(value, key) {\n    this.attributeInSchema(key);\n\n    /**\n     * TODO: La validacion debe ser mas inteligente\n     * Es necesario verificar si es un Array, no este vacio\n     * Si es un string, no este vacio\n     * o Undefined para ambos casos\n     * Esto, cuando son requeridos.\n     */\n    if (this.valueRequired(key) && (value === undefined || value.length === 0)) {\n      throw ERRORS.att_required(key);\n    }\n\n    this.validateType(key, value);\n\n    if (this.isEnumInAttribute(key)) {\n      this.valueInEnum(key, value);\n    }\n\n    return value;\n  }\n\n  /**\n   * Validate the value against the typo given in the schema for the attribute\n   * @param {any} key\n   * @param {any} input\n   * @memberof Validator\n   */\n  validateType(key, input) {\n    if (this.schema.isNestedSchema(key)) return input;\n\n    if (input.constructor !== this.schema[key].type && Object.keys(this.schema[key]).includes('type')) {\n      const type = this.schema[key].type.toString().match(/[A-Z][a-z]+/g)[0];\n\n      throw ERRORS.not_valid_typo(key, type);\n    }\n\n    return input;\n  }\n\n\n  /**\n   * Create and apply a proxy to an object using the current\n   * schema when the validator was created\n   * @param {any} object\n   * @returns newObjectWithProxy\n   * @memberof Validator\n   */\n  generateProxy(object) {\n    if (!object) throw ERRORS.emtpy_param('Object or Class');\n\n    const handler = createHandler(this);\n\n    const withProxy = new Proxy(object, handler);\n\n    return withProxy;\n  }\n}\n\nexport default Validator;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}