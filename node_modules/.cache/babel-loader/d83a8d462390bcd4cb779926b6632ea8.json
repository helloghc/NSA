{"ast":null,"code":"import _defineProperty from\"/Users/mac/Desktop/sky/skyalert-New/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";import _toConsumableArray from\"/Users/mac/Desktop/sky/skyalert-New/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";import _classCallCheck from\"/Users/mac/Desktop/sky/skyalert-New/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";import _createClass from\"/Users/mac/Desktop/sky/skyalert-New/node_modules/@babel/runtime/helpers/esm/createClass.js\";import _objectSpread from\"/Users/mac/Desktop/sky/skyalert-New/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";// TODO: Refactor some code\nimport ERRORS from'./errors';/**\n * Every valid options to create an Schema object\n */var SCHEMA_OPTIONS={type:[Boolean,Date,Number,String,Array],required:Boolean,enum:[],editable:Boolean,label:String,enumLabels:Array};/**\n * Check constructrors\n * @param {String} att\n * @param {constructor} type\n */var checkConstructor=function checkConstructor(att,type){if(att.constructor!==type){throw ERRORS.not_valid_typo(att,type);}};/**\n * Looks if the schema object is empty\n * @param {Object} [param]\n * @returns {Object}\n */var checkParam=function checkParam(){var param=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};if(Object.prototype.toString.call(param)!=='[object Object]'){throw ERRORS.not_valid_typo('Schema','Object','The Schema must be an Object');}if(Object.keys(param).length===0){throw ERRORS.empty_object('Schema constructor cannot be empty');}return _objectSpread({},param);};/**\n * @param {Object} model\n * @param {Object} object\n * @returns {Object} santizied\n */var checkSchema=function checkSchema(){var schema=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};/* eslint-disable-next-line */if(schema.constructor===Schema){return _objectSpread({},schema);}if(Object.prototype.toString.call(schema)!=='[object Object]'){throw ERRORS.not_valid_typo('Schema','Object');}if(Object.keys(schema).length===0){throw ERRORS.empty_object('Schema object cannot be empty. At least must have \"type\" attribute');}if(!schema.type)throw ERRORS.att_required('type');return _objectSpread({},schema);};/**\n * Check the delivered schema against his options\n * @param {object} schema\n * @returns [schema]\n */var checkSchemaOptions=function checkSchemaOptions(){var schema=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};Object.keys(schema).forEach(function(key){/* eslint-disable-next-line */if(schema[key].constructor===Schema||schema[key].constructor===Object&&Object.keys(schema[key]).length>0){return;}/* eslint-disable indent */switch(key){case'type':if(!SCHEMA_OPTIONS[key].includes(schema[key])){var value=schema[key].toString().match(/[A-Z][a-z]+/g)[0];var arr=SCHEMA_OPTIONS[key].map(function(type){return type.toString().match(/[A-Z][a-z]+/g)[0];});throw ERRORS.not_in_enum(key,value,arr);}break;case'required':checkConstructor(schema[key],SCHEMA_OPTIONS[key]);break;case'label':checkConstructor(schema[key],SCHEMA_OPTIONS[key]);break;case'editable':checkConstructor(schema[key],SCHEMA_OPTIONS[key]);break;case'enum':if(!Array.isArray(schema[key]))throw ERRORS.not_valid_typo(schema[key],Array);schema[key].forEach(function(element){if(element.constructor!==schema.type){var msg=\"\".concat(element.constructor.toString().match(/[A-Z][a-z]+/g)[0],\" given, must be \").concat(schema.type.toString().match(/[A-Z][a-z]+/g)[0]);throw ERRORS.not_valid_typo(element,schema.type,msg);}});break;case'enumLabels':checkConstructor(schema[key],SCHEMA_OPTIONS[key]);break;/* eslint-enable indent */ /* eslint-disable  */default:if(schema[key].constructor!==Object&&!schema[key].type){throw ERRORS.att_not_valid(key,\"\".concat(key,\" is not a valid options for Schema Object\"));}var nestedObject=_objectSpread({},schema[key]);nestedObject=checkSchemaOptions(checkSchema(nestedObject));schema[key]=_objectSpread({},nestedObject);break;/* eslint-enable */}});return _objectSpread({},schema);};/**\n * Manage an Schema to validate every Model instance\n * @class Schema\n */ /* eslint-disable class-methods-use-this */var Schema=/*#__PURE__*/function(){/**\n   * Creates an instance of Schema.\n   * @param {Object} [schema]\n   * @memberof Schema\n   */function Schema(){var _this=this;var schema=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};_classCallCheck(this,Schema);var sanitized=checkParam(schema);Object.keys(sanitized).forEach(function(key){_this[key]=checkSchemaOptions(checkSchema(sanitized[key]));_this[key].required=_this[key].required||false;});}/**\n   * Returns true if the given key are in\n   * the Schema\n   * @param {String} key\n   * @returns Boolean\n   * @memberof Schema\n   */_createClass(Schema,[{key:\"attributeInSchema\",value:function attributeInSchema(key){return Object.keys(this).includes(key);}/**\n   * Return true if the Schema attribute is\n   * a nested object\n   * @param {Any} attr Could be a String or an Object\n   * @returns Boolean\n   * @memberof Schema\n   */},{key:\"isNestedSchema\",value:function isNestedSchema(attr){if(attr.constructor===Object){return!('type'in attr)||attr.type.constructor===Object;}return!('type'in this[attr])||this[attr].type.constructor===Object;}/**\n   * Return all the options of the given entry\n   * @param {any} key\n   * @returns Object\n   * @memberof Schema\n   */},{key:\"getAttribute\",value:function getAttribute(key){return this.attributeInSchema(key)?_objectSpread({},this[key]):undefined;}/**\n   * Returns the value of required option in\n   * attribute\n   * @param {Any} attr Attribute to look for required option. Could be String or Object\n   * @returns Boolean\n   * @memberof Schema\n   */},{key:\"isEditable\",value:function isEditable(attr){if(attr.constructor===Object){return'editable'in attr&&attr.editable;}return this[attr].editable;}/**\n   * Get all nested attributes who are editable\n   * @param {Object} attr Object to extract the values\n   * @param {String} name Name(key) of the Object\n   * @returns Array\n   * @memberof Schema\n   */},{key:\"getNestedEditable\",value:function getNestedEditable(attr,name,nested){var _this2=this;return Object.keys(attr).reduce(function(acc,key){if(['required','editable'].includes(key))return _toConsumableArray(acc);if(!('type'in attr[key])){return[].concat(_toConsumableArray(acc),_toConsumableArray(_this2.getNestedEditable(attr[key],name,key)));}if(_this2.isEditable(attr[key]))return[].concat(_toConsumableArray(acc),[!nested?\"\".concat(name,\".\").concat(key):\"\".concat(name,\".\").concat(nested,\".\").concat(key)]);return _toConsumableArray(acc);},[]);}/**\n   * Get all attributes that can be edited\n   * @returns Array\n   * @memberof Schema\n   */},{key:\"getAllEditable\",value:function getAllEditable(){var _this3=this;return Object.keys(this).reduce(function(acc,key){if(_this3.isNestedSchema(key)){return[].concat(_toConsumableArray(acc),_toConsumableArray(_this3.getNestedEditable(_this3[key],key)));}if(_this3.isEditable(key)){return[].concat(_toConsumableArray(acc),[key]);}return _toConsumableArray(acc);},[]);}/**\n   * Get label for the given object\n   * If the attribute doesn't have a label\n   * it return false;\n   * @param {Any} attr Attribute to look for required option. Could be String or Object\n   * @returns String or Boolean\n   * @memberof Schema\n   */},{key:\"getLabel\",value:function getLabel(attr){var nested=this.isNestedSchema(attr);if(attr.constructor===Object&&!nested){return'label'in attr?attr.label:undefined;}if(nested){this.getLabel(attr);}return this[attr].label;}/**\n * Get all nested labels an returns as an Object\n * @param {Object} attr Object to extract the labels\n * @param {String} name Name(key) of the Object\n * @param {String} nested Second key to go through second layer of the object\n * @returns Object\n * @memberof Schema\n */},{key:\"getNestedLabels\",value:function getNestedLabels(attr,name){var _this4=this;var nested=arguments.length>2&&arguments[2]!==undefined?arguments[2]:undefined;return Object.keys(attr).reduce(function(acc,key){if(['required','editable'].includes(key))return _objectSpread({},acc);if(_this4.isNestedSchema(attr[key])){return _objectSpread(_objectSpread({},acc),_this4.getNestedLabels(attr[key],name,key));}var label=_this4.getLabel(attr[key]);if(label){return _objectSpread(_objectSpread({},acc),{},_defineProperty({},!nested?\"\".concat(name,\".\").concat(key):\"\".concat(name,\".\").concat(nested,\".\").concat(key),label));}return _objectSpread({},acc);},{});}/**\n   * Get all labels from the attributes in the\n   * Schema\n   * @returns Object\n   * @memberof Schema\n   */},{key:\"getAllLabels\",value:function getAllLabels(){var _this5=this;return Object.keys(this).reduce(function(acc,key){if(_this5.isNestedSchema(_this5[key])){var nested=_objectSpread({},_this5.getNestedLabels(_this5[key],key));return nested?_objectSpread(_objectSpread({},acc),nested):_objectSpread({},acc);}var label=_this5.getLabel(_this5[key]);if(label){return _objectSpread(_objectSpread({},acc),{},_defineProperty({},key,label));}return _objectSpread({},acc);},{});}/**\n   * Returns the value in required option\n   * @param {Object} attr Could be Object or String\n   * @returns Boolean\n   * @memberof Schema\n   */},{key:\"isRequired\",value:function isRequired(attr){if(attr.constructor===Object){return'required'in attr?attr.required:false;}return this[attr].required;}/**\n  * Get all nested required an returns as an Array\n  * @param {Object} attr Object to extract the labels\n  * @param {String} name Name(key) of the Object\n  * @param {String} nested Second key to go through second layer of the object\n  * @returns Array\n  * @memberof Schema\n  */},{key:\"getNestedRequired\",value:function getNestedRequired(attr,name){var _this6=this;var nested=arguments.length>2&&arguments[2]!==undefined?arguments[2]:undefined;return Object.keys(attr).reduce(function(acc,key){if(['required','editable'].includes(key))return _toConsumableArray(acc);if(_this6.isNestedSchema(attr[key])){return[].concat(_toConsumableArray(acc),_toConsumableArray(_this6.getNestedRequired(attr[key],name,key)));}if(_this6.isRequired(attr[key])){return[].concat(_toConsumableArray(acc),[!nested?\"\".concat(name,\".\").concat(key):\"\".concat(name,\".\").concat(nested,\".\").concat(key)]);}return _toConsumableArray(acc);},[]);}/**\n   * Returns all the attributes that required\n   * are true. If no there's not, return an Empty Array\n   * @returns Array\n   * @memberof Schema\n   */},{key:\"getAllRequired\",value:function getAllRequired(){var _this7=this;return Object.keys(this).reduce(function(acc,key){if(_this7.isNestedSchema(key)){var nested=_this7.getNestedRequired(_this7[key],key);if(nested.length>0)return[].concat(_toConsumableArray(acc),_toConsumableArray(nested));}if(_this7.isRequired(key)){return[].concat(_toConsumableArray(acc),[key]);}return _toConsumableArray(acc);},[]);}/**\n   * Get the type of an attribute\n   * If invalid attribute, it returns undefined\n   * @param {any} attr Could be String or an Object\n   * @returns Constructor\n   * @memberof Schema\n   */},{key:\"getType\",value:function getType(attr){if(attr.constructor===Object){return'type'in attr?attr.type:undefined;}return this[attr].type;}/**\n  * Get all nested types and returns as an Object\n  * @param {Object} attr Object to extract the labels\n  * @param {String} name Name(key) of the Object\n  * @param {String} nested Second key to go through second layer of the object\n  * @returns Object\n  * @memberof Schema\n  */},{key:\"getNestedTypes\",value:function getNestedTypes(attr,name){var _this8=this;var nested=arguments.length>2&&arguments[2]!==undefined?arguments[2]:undefined;return Object.keys(attr).reduce(function(acc,key){if(['required','editable'].includes(key))return _objectSpread({},acc);if(_this8.isNestedSchema(attr[key])){return _objectSpread(_objectSpread({},acc),_this8.getNestedTypes(attr[key],name,key));}var type=_this8.getType(attr[key]);if(type){return _objectSpread(_objectSpread({},acc),{},_defineProperty({},!nested?\"\".concat(name,\".\").concat(key):\"\".concat(name,\".\").concat(nested,\".\").concat(key),type));}return _objectSpread({},acc);},{});}/**\n   * Returns an Object with key/value for\n   * each attribute and his type value.\n   * @returns Object\n   * @memberof Schema\n   */},{key:\"getAllTypes\",value:function getAllTypes(){var _this9=this;return Object.keys(this).reduce(function(acc,key){if(_this9.isNestedSchema(_this9[key])){var nested=_objectSpread({},_this9.getNestedTypes(_this9[key],key));return nested?_objectSpread(_objectSpread({},acc),nested):_objectSpread({},acc);}var type=_this9.getType(_this9[key]);if(type){return _objectSpread(_objectSpread({},acc),{},_defineProperty({},key,type));}return _objectSpread({},acc);},{});}/**\n   * Returns true if the attribute has an enum option\n   * defined\n   * @param {Any} attr Could be String or Object\n   * @returns Boolean\n   * @memberof Schema\n   */},{key:\"hasEnum\",value:function hasEnum(attr){if(attr.constructor===Object){return'enum'in attr;}return'enum'in this[attr];}/**\n   * Return the specified enum option of the\n   * attribute given. If doesnt have, return undefined\n   * @param {Any} attr Could be String or Object\n   * @returns Array or Undefined\n   * @memberof Schema\n   */},{key:\"getEnum\",value:function getEnum(attr){if(attr.constructor===Object){return this.hasEnum(attr)?_toConsumableArray(attr.enum):undefined;}return'enum'in this[attr]?_toConsumableArray(this[attr].enum):undefined;}/**\n   * Return an object with all attributes an options.\n   * Functions are ignored;\n   * @returns Object\n   * @memberof Schema\n   */},{key:\"getAllAtributes\",value:function getAllAtributes(){var _this10=this;return Object.keys(this).reduce(function(acc,key){if(_this10[key].constructor!==Function){return _objectSpread(_objectSpread({},acc),{},_defineProperty({},key,_this10.getAttribute(key)));}return _objectSpread({},acc);},{});}}]);return Schema;}();export{Schema as default};","map":{"version":3,"names":["ERRORS","SCHEMA_OPTIONS","type","Boolean","Date","Number","String","Array","required","enum","editable","label","enumLabels","checkConstructor","att","constructor","not_valid_typo","checkParam","param","Object","prototype","toString","call","keys","length","empty_object","checkSchema","schema","Schema","att_required","checkSchemaOptions","forEach","key","includes","value","match","arr","map","not_in_enum","isArray","element","msg","att_not_valid","nestedObject","sanitized","attr","attributeInSchema","undefined","name","nested","reduce","acc","getNestedEditable","isEditable","isNestedSchema","getLabel","getNestedLabels","getNestedRequired","isRequired","getNestedTypes","getType","hasEnum","Function","getAttribute"],"sources":["/Users/mac/Desktop/sky/skyalert-New/src/utils/schema.js"],"sourcesContent":["// TODO: Refactor some code\n\nimport ERRORS from './errors';\n\n/**\n * Every valid options to create an Schema object\n */\nconst SCHEMA_OPTIONS = {\n  type: [Boolean, Date, Number, String, Array],\n  required: Boolean,\n  enum: [],\n  editable: Boolean,\n  label: String,\n  enumLabels: Array,\n};\n\n/**\n * Check constructrors\n * @param {String} att\n * @param {constructor} type\n */\nconst checkConstructor = (att, type) => {\n  if (att.constructor !== type) {\n    throw ERRORS.not_valid_typo(att, type);\n  }\n};\n\n/**\n * Looks if the schema object is empty\n * @param {Object} [param]\n * @returns {Object}\n */\nconst checkParam = (param = {}) => {\n  if (Object.prototype.toString.call(param) !== '[object Object]') {\n    throw ERRORS.not_valid_typo('Schema', 'Object', 'The Schema must be an Object');\n  }\n\n  if (Object.keys(param).length === 0) {\n    throw ERRORS.empty_object('Schema constructor cannot be empty');\n  }\n\n  return { ...param };\n};\n\n/**\n * @param {Object} model\n * @param {Object} object\n * @returns {Object} santizied\n */\nconst checkSchema = (schema = {}) => {\n  /* eslint-disable-next-line */\n  if (schema.constructor === Schema) {\n    return { ...schema };\n  }\n\n  if (Object.prototype.toString.call(schema) !== '[object Object]') {\n    throw ERRORS.not_valid_typo('Schema', 'Object');\n  }\n\n  if (Object.keys(schema).length === 0) {\n    throw ERRORS.empty_object('Schema object cannot be empty. At least must have \"type\" attribute');\n  }\n\n  if (!schema.type) throw ERRORS.att_required('type');\n\n  return { ...schema };\n};\n\n/**\n * Check the delivered schema against his options\n * @param {object} schema\n * @returns [schema]\n */\nconst checkSchemaOptions = (schema = {}) => {\n  Object.keys(schema).forEach((key) => {\n    /* eslint-disable-next-line */\n    if (schema[key].constructor === Schema || (schema[key].constructor === Object\n      && Object.keys(schema[key]).length > 0)) {\n      return;\n    }\n\n    /* eslint-disable indent */\n    switch (key) {\n      case 'type':\n        if (!SCHEMA_OPTIONS[key].includes(schema[key])) {\n          const value = schema[key].toString().match(/[A-Z][a-z]+/g)[0];\n          const arr = SCHEMA_OPTIONS[key].map(type => type.toString().match(/[A-Z][a-z]+/g)[0]);\n\n          throw ERRORS.not_in_enum(key, value, arr);\n        }\n        break;\n\n      case 'required':\n        checkConstructor(schema[key], SCHEMA_OPTIONS[key]);\n        break;\n\n      case 'label':\n        checkConstructor(schema[key], SCHEMA_OPTIONS[key]);\n        break;\n\n      case 'editable':\n        checkConstructor(schema[key], SCHEMA_OPTIONS[key]);\n        break;\n\n      case 'enum':\n        if (!Array.isArray(schema[key])) throw ERRORS.not_valid_typo(schema[key], Array);\n\n        schema[key].forEach((element) => {\n          if (element.constructor !== schema.type) {\n            const msg = `${element.constructor.toString().match(/[A-Z][a-z]+/g)[0]} given, must be ${schema.type.toString().match(/[A-Z][a-z]+/g)[0]}`;\n            throw ERRORS.not_valid_typo(element, schema.type, msg);\n          }\n        });\n        break;\n\n      case 'enumLabels':\n        checkConstructor(schema[key], SCHEMA_OPTIONS[key]);\n        break;\n      /* eslint-enable indent */\n\n      /* eslint-disable  */\n      default:\n\n        if (schema[key].constructor !== Object && !schema[key].type) {\n          throw ERRORS.att_not_valid(key, `${key} is not a valid options for Schema Object`);\n        }\n\n        let nestedObject = { ...schema[key] };\n\n        nestedObject = checkSchemaOptions(checkSchema(nestedObject));\n\n        schema[key] = { ...nestedObject };\n        break;\n      /* eslint-enable */\n    }\n  });\n\n  return { ...schema };\n};\n\n\n/**\n * Manage an Schema to validate every Model instance\n * @class Schema\n */\n/* eslint-disable class-methods-use-this */\nexport default class Schema {\n  /**\n   * Creates an instance of Schema.\n   * @param {Object} [schema]\n   * @memberof Schema\n   */\n  constructor(schema = {}) {\n    const sanitized = checkParam(schema);\n\n    Object.keys(sanitized).forEach((key) => {\n      this[key] = checkSchemaOptions(checkSchema(sanitized[key]));\n\n      this[key].required = this[key].required || false;\n    });\n  }\n\n  /**\n   * Returns true if the given key are in\n   * the Schema\n   * @param {String} key\n   * @returns Boolean\n   * @memberof Schema\n   */\n  attributeInSchema(key) {\n    return Object.keys(this).includes(key);\n  }\n\n  /**\n   * Return true if the Schema attribute is\n   * a nested object\n   * @param {Any} attr Could be a String or an Object\n   * @returns Boolean\n   * @memberof Schema\n   */\n  isNestedSchema(attr) {\n    if (attr.constructor === Object) {\n      return (!('type' in attr) || attr.type.constructor === Object);\n    }\n    return (!('type' in this[attr]) || this[attr].type.constructor === Object);\n  }\n\n  /**\n   * Return all the options of the given entry\n   * @param {any} key\n   * @returns Object\n   * @memberof Schema\n   */\n  getAttribute(key) {\n    return (this.attributeInSchema(key)) ? { ...this[key] } : undefined;\n  }\n\n  /**\n   * Returns the value of required option in\n   * attribute\n   * @param {Any} attr Attribute to look for required option. Could be String or Object\n   * @returns Boolean\n   * @memberof Schema\n   */\n  isEditable(attr) {\n    if (attr.constructor === Object) {\n      return ('editable' in attr && attr.editable);\n    }\n\n    return this[attr].editable;\n  }\n\n  /**\n   * Get all nested attributes who are editable\n   * @param {Object} attr Object to extract the values\n   * @param {String} name Name(key) of the Object\n   * @returns Array\n   * @memberof Schema\n   */\n  getNestedEditable(attr, name, nested) {\n    return Object.keys(attr).reduce((acc, key) => {\n      if (['required', 'editable'].includes(key)) return [...acc];\n\n      if (!('type' in attr[key])) {\n        return [...acc, ...this.getNestedEditable(attr[key], name, key)];\n      }\n\n      if (this.isEditable(attr[key])) return [...acc, (!nested) ? `${name}.${key}` : `${name}.${nested}.${key}`];\n\n      return [...acc];\n    }, []);\n  }\n\n  /**\n   * Get all attributes that can be edited\n   * @returns Array\n   * @memberof Schema\n   */\n  getAllEditable() {\n    return Object.keys(this)\n      .reduce((acc, key) => {\n        if (this.isNestedSchema(key)) {\n          return [...acc, ...this.getNestedEditable(this[key], key)];\n        }\n\n        if (this.isEditable(key)) {\n          return [...acc, key];\n        }\n\n        return [...acc];\n      }, []);\n  }\n\n  /**\n   * Get label for the given object\n   * If the attribute doesn't have a label\n   * it return false;\n   * @param {Any} attr Attribute to look for required option. Could be String or Object\n   * @returns String or Boolean\n   * @memberof Schema\n   */\n  getLabel(attr) {\n    const nested = this.isNestedSchema(attr);\n\n    if (attr.constructor === Object && !nested) {\n      return ('label' in attr) ? attr.label : undefined;\n    }\n\n    if (nested) {\n      this.getLabel(attr);\n    }\n\n    return this[attr].label;\n  }\n\n  /**\n * Get all nested labels an returns as an Object\n * @param {Object} attr Object to extract the labels\n * @param {String} name Name(key) of the Object\n * @param {String} nested Second key to go through second layer of the object\n * @returns Object\n * @memberof Schema\n */\n  getNestedLabels(attr, name, nested = undefined) {\n    return Object.keys(attr).reduce((acc, key) => {\n      if (['required', 'editable'].includes(key)) return { ...acc };\n\n      if (this.isNestedSchema(attr[key])) {\n        return { ...acc, ...this.getNestedLabels(attr[key], name, key) };\n      }\n\n      const label = this.getLabel(attr[key]);\n      if (label) {\n        return { ...acc, [(!nested) ? `${name}.${key}` : `${name}.${nested}.${key}`]: label };\n      }\n\n      return { ...acc };\n    }, {});\n  }\n\n  /**\n   * Get all labels from the attributes in the\n   * Schema\n   * @returns Object\n   * @memberof Schema\n   */\n  getAllLabels() {\n    return Object.keys(this).reduce((acc, key) => {\n      if (this.isNestedSchema(this[key])) {\n        const nested = { ...this.getNestedLabels(this[key], key) };\n        return (nested) ? { ...acc, ...nested } : { ...acc };\n      }\n\n      const label = this.getLabel(this[key]);\n      if (label) {\n        return { ...acc, [key]: label };\n      }\n\n      return { ...acc };\n    }, {});\n  }\n\n  /**\n   * Returns the value in required option\n   * @param {Object} attr Could be Object or String\n   * @returns Boolean\n   * @memberof Schema\n   */\n  isRequired(attr) {\n    if (attr.constructor === Object) {\n      return ('required' in attr) ? attr.required : false;\n    }\n\n    return this[attr].required;\n  }\n\n  /**\n  * Get all nested required an returns as an Array\n  * @param {Object} attr Object to extract the labels\n  * @param {String} name Name(key) of the Object\n  * @param {String} nested Second key to go through second layer of the object\n  * @returns Array\n  * @memberof Schema\n  */\n  getNestedRequired(attr, name, nested = undefined) {\n    return Object.keys(attr).reduce((acc, key) => {\n      if (['required', 'editable'].includes(key)) return [...acc];\n\n      if (this.isNestedSchema(attr[key])) {\n        return [...acc, ...this.getNestedRequired(attr[key], name, key)];\n      }\n\n      if (this.isRequired(attr[key])) {\n        return [...acc, (!nested) ? `${name}.${key}` : `${name}.${nested}.${key}`];\n      }\n\n      return [...acc];\n    }, []);\n  }\n\n  /**\n   * Returns all the attributes that required\n   * are true. If no there's not, return an Empty Array\n   * @returns Array\n   * @memberof Schema\n   */\n  getAllRequired() {\n    return Object.keys(this)\n      .reduce((acc, key) => {\n        if (this.isNestedSchema(key)) {\n          const nested = this.getNestedRequired(this[key], key);\n\n          if (nested.length > 0) return [...acc, ...nested];\n        }\n\n        if (this.isRequired(key)) {\n          return [...acc, key];\n        }\n\n        return [...acc];\n      }, []);\n  }\n\n  /**\n   * Get the type of an attribute\n   * If invalid attribute, it returns undefined\n   * @param {any} attr Could be String or an Object\n   * @returns Constructor\n   * @memberof Schema\n   */\n  getType(attr) {\n    if (attr.constructor === Object) {\n      return ('type' in attr) ? attr.type : undefined;\n    }\n\n    return this[attr].type;\n  }\n\n  /**\n  * Get all nested types and returns as an Object\n  * @param {Object} attr Object to extract the labels\n  * @param {String} name Name(key) of the Object\n  * @param {String} nested Second key to go through second layer of the object\n  * @returns Object\n  * @memberof Schema\n  */\n  getNestedTypes(attr, name, nested = undefined) {\n    return Object.keys(attr).reduce((acc, key) => {\n      if (['required', 'editable'].includes(key)) return { ...acc };\n\n      if (this.isNestedSchema(attr[key])) {\n        return { ...acc, ...this.getNestedTypes(attr[key], name, key) };\n      }\n\n      const type = this.getType(attr[key]);\n      if (type) {\n        return { ...acc, [(!nested) ? `${name}.${key}` : `${name}.${nested}.${key}`]: type };\n      }\n\n      return { ...acc };\n    }, {});\n  }\n\n  /**\n   * Returns an Object with key/value for\n   * each attribute and his type value.\n   * @returns Object\n   * @memberof Schema\n   */\n  getAllTypes() {\n    return Object.keys(this).reduce((acc, key) => {\n      if (this.isNestedSchema(this[key])) {\n        const nested = { ...this.getNestedTypes(this[key], key) };\n        return (nested) ? { ...acc, ...nested } : { ...acc };\n      }\n\n      const type = this.getType(this[key]);\n      if (type) {\n        return { ...acc, [key]: type };\n      }\n\n      return { ...acc };\n    }, {});\n  }\n\n  /**\n   * Returns true if the attribute has an enum option\n   * defined\n   * @param {Any} attr Could be String or Object\n   * @returns Boolean\n   * @memberof Schema\n   */\n  hasEnum(attr) {\n    if (attr.constructor === Object) {\n      return ('enum' in attr);\n    }\n\n    return ('enum' in this[attr]);\n  }\n\n  /**\n   * Return the specified enum option of the\n   * attribute given. If doesnt have, return undefined\n   * @param {Any} attr Could be String or Object\n   * @returns Array or Undefined\n   * @memberof Schema\n   */\n  getEnum(attr) {\n    if (attr.constructor === Object) {\n      return (this.hasEnum(attr)) ? [...attr.enum] : undefined;\n    }\n\n    return ('enum' in this[attr]) ? [...this[attr].enum] : undefined;\n  }\n\n  /**\n   * Return an object with all attributes an options.\n   * Functions are ignored;\n   * @returns Object\n   * @memberof Schema\n   */\n  getAllAtributes() {\n    return Object.keys(this).reduce((acc, key) => {\n      if (this[key].constructor !== Function) {\n        return { ...acc, [key]: this.getAttribute(key) };\n      }\n\n      return { ...acc };\n    }, {});\n  }\n}\n"],"mappings":"omBAAA;AAEA,MAAOA,OAAP,KAAmB,UAAnB,CAEA;AACA;AACA,GACA,GAAMC,eAAc,CAAG,CACrBC,IAAI,CAAE,CAACC,OAAD,CAAUC,IAAV,CAAgBC,MAAhB,CAAwBC,MAAxB,CAAgCC,KAAhC,CADe,CAErBC,QAAQ,CAAEL,OAFW,CAGrBM,IAAI,CAAE,EAHe,CAIrBC,QAAQ,CAAEP,OAJW,CAKrBQ,KAAK,CAAEL,MALc,CAMrBM,UAAU,CAAEL,KANS,CAAvB,CASA;AACA;AACA;AACA;AACA,GACA,GAAMM,iBAAgB,CAAG,QAAnBA,iBAAmB,CAACC,GAAD,CAAMZ,IAAN,CAAe,CACtC,GAAIY,GAAG,CAACC,WAAJ,GAAoBb,IAAxB,CAA8B,CAC5B,KAAMF,OAAM,CAACgB,cAAP,CAAsBF,GAAtB,CAA2BZ,IAA3B,CAAN,CACD,CACF,CAJD,CAMA;AACA;AACA;AACA;AACA,GACA,GAAMe,WAAU,CAAG,QAAbA,WAAa,EAAgB,IAAfC,MAAe,2DAAP,EAAO,CACjC,GAAIC,MAAM,CAACC,SAAP,CAAiBC,QAAjB,CAA0BC,IAA1B,CAA+BJ,KAA/B,IAA0C,iBAA9C,CAAiE,CAC/D,KAAMlB,OAAM,CAACgB,cAAP,CAAsB,QAAtB,CAAgC,QAAhC,CAA0C,8BAA1C,CAAN,CACD,CAED,GAAIG,MAAM,CAACI,IAAP,CAAYL,KAAZ,EAAmBM,MAAnB,GAA8B,CAAlC,CAAqC,CACnC,KAAMxB,OAAM,CAACyB,YAAP,CAAoB,oCAApB,CAAN,CACD,CAED,wBAAYP,KAAZ,EACD,CAVD,CAYA;AACA;AACA;AACA;AACA,GACA,GAAMQ,YAAW,CAAG,QAAdA,YAAc,EAAiB,IAAhBC,OAAgB,2DAAP,EAAO,CACnC,8BACA,GAAIA,MAAM,CAACZ,WAAP,GAAuBa,MAA3B,CAAmC,CACjC,wBAAYD,MAAZ,EACD,CAED,GAAIR,MAAM,CAACC,SAAP,CAAiBC,QAAjB,CAA0BC,IAA1B,CAA+BK,MAA/B,IAA2C,iBAA/C,CAAkE,CAChE,KAAM3B,OAAM,CAACgB,cAAP,CAAsB,QAAtB,CAAgC,QAAhC,CAAN,CACD,CAED,GAAIG,MAAM,CAACI,IAAP,CAAYI,MAAZ,EAAoBH,MAApB,GAA+B,CAAnC,CAAsC,CACpC,KAAMxB,OAAM,CAACyB,YAAP,CAAoB,oEAApB,CAAN,CACD,CAED,GAAI,CAACE,MAAM,CAACzB,IAAZ,CAAkB,KAAMF,OAAM,CAAC6B,YAAP,CAAoB,MAApB,CAAN,CAElB,wBAAYF,MAAZ,EACD,CAjBD,CAmBA;AACA;AACA;AACA;AACA,GACA,GAAMG,mBAAkB,CAAG,QAArBA,mBAAqB,EAAiB,IAAhBH,OAAgB,2DAAP,EAAO,CAC1CR,MAAM,CAACI,IAAP,CAAYI,MAAZ,EAAoBI,OAApB,CAA4B,SAACC,GAAD,CAAS,CACnC,8BACA,GAAIL,MAAM,CAACK,GAAD,CAAN,CAAYjB,WAAZ,GAA4Ba,MAA5B,EAAuCD,MAAM,CAACK,GAAD,CAAN,CAAYjB,WAAZ,GAA4BI,MAA5B,EACtCA,MAAM,CAACI,IAAP,CAAYI,MAAM,CAACK,GAAD,CAAlB,EAAyBR,MAAzB,CAAkC,CADvC,CAC2C,CACzC,OACD,CAED,2BACA,OAAQQ,GAAR,EACE,IAAK,MAAL,CACE,GAAI,CAAC/B,cAAc,CAAC+B,GAAD,CAAd,CAAoBC,QAApB,CAA6BN,MAAM,CAACK,GAAD,CAAnC,CAAL,CAAgD,CAC9C,GAAME,MAAK,CAAGP,MAAM,CAACK,GAAD,CAAN,CAAYX,QAAZ,GAAuBc,KAAvB,CAA6B,cAA7B,EAA6C,CAA7C,CAAd,CACA,GAAMC,IAAG,CAAGnC,cAAc,CAAC+B,GAAD,CAAd,CAAoBK,GAApB,CAAwB,SAAAnC,IAAI,QAAIA,KAAI,CAACmB,QAAL,GAAgBc,KAAhB,CAAsB,cAAtB,EAAsC,CAAtC,CAAJ,EAA5B,CAAZ,CAEA,KAAMnC,OAAM,CAACsC,WAAP,CAAmBN,GAAnB,CAAwBE,KAAxB,CAA+BE,GAA/B,CAAN,CACD,CACD,MAEF,IAAK,UAAL,CACEvB,gBAAgB,CAACc,MAAM,CAACK,GAAD,CAAP,CAAc/B,cAAc,CAAC+B,GAAD,CAA5B,CAAhB,CACA,MAEF,IAAK,OAAL,CACEnB,gBAAgB,CAACc,MAAM,CAACK,GAAD,CAAP,CAAc/B,cAAc,CAAC+B,GAAD,CAA5B,CAAhB,CACA,MAEF,IAAK,UAAL,CACEnB,gBAAgB,CAACc,MAAM,CAACK,GAAD,CAAP,CAAc/B,cAAc,CAAC+B,GAAD,CAA5B,CAAhB,CACA,MAEF,IAAK,MAAL,CACE,GAAI,CAACzB,KAAK,CAACgC,OAAN,CAAcZ,MAAM,CAACK,GAAD,CAApB,CAAL,CAAiC,KAAMhC,OAAM,CAACgB,cAAP,CAAsBW,MAAM,CAACK,GAAD,CAA5B,CAAmCzB,KAAnC,CAAN,CAEjCoB,MAAM,CAACK,GAAD,CAAN,CAAYD,OAAZ,CAAoB,SAACS,OAAD,CAAa,CAC/B,GAAIA,OAAO,CAACzB,WAAR,GAAwBY,MAAM,CAACzB,IAAnC,CAAyC,CACvC,GAAMuC,IAAG,WAAMD,OAAO,CAACzB,WAAR,CAAoBM,QAApB,GAA+Bc,KAA/B,CAAqC,cAArC,EAAqD,CAArD,CAAN,4BAAgFR,MAAM,CAACzB,IAAP,CAAYmB,QAAZ,GAAuBc,KAAvB,CAA6B,cAA7B,EAA6C,CAA7C,CAAhF,CAAT,CACA,KAAMnC,OAAM,CAACgB,cAAP,CAAsBwB,OAAtB,CAA+Bb,MAAM,CAACzB,IAAtC,CAA4CuC,GAA5C,CAAN,CACD,CACF,CALD,EAMA,MAEF,IAAK,YAAL,CACE5B,gBAAgB,CAACc,MAAM,CAACK,GAAD,CAAP,CAAc/B,cAAc,CAAC+B,GAAD,CAA5B,CAAhB,CACA,MACF,0BApCF,CAsCE,qBACA,QAEE,GAAIL,MAAM,CAACK,GAAD,CAAN,CAAYjB,WAAZ,GAA4BI,MAA5B,EAAsC,CAACQ,MAAM,CAACK,GAAD,CAAN,CAAY9B,IAAvD,CAA6D,CAC3D,KAAMF,OAAM,CAAC0C,aAAP,CAAqBV,GAArB,WAA6BA,GAA7B,8CAAN,CACD,CAED,GAAIW,aAAY,kBAAQhB,MAAM,CAACK,GAAD,CAAd,CAAhB,CAEAW,YAAY,CAAGb,kBAAkB,CAACJ,WAAW,CAACiB,YAAD,CAAZ,CAAjC,CAEAhB,MAAM,CAACK,GAAD,CAAN,kBAAmBW,YAAnB,EACA,MACF,mBAnDF,CAqDD,CA7DD,EA+DA,wBAAYhB,MAAZ,EACD,CAjED,CAoEA;AACA;AACA;AACA,G,CACA,2C,GACqBC,O,yBACnB;AACF;AACA;AACA;AACA,KACE,iBAAyB,mBAAbD,OAAa,2DAAJ,EAAI,8BACvB,GAAMiB,UAAS,CAAG3B,UAAU,CAACU,MAAD,CAA5B,CAEAR,MAAM,CAACI,IAAP,CAAYqB,SAAZ,EAAuBb,OAAvB,CAA+B,SAACC,GAAD,CAAS,CACtC,KAAI,CAACA,GAAD,CAAJ,CAAYF,kBAAkB,CAACJ,WAAW,CAACkB,SAAS,CAACZ,GAAD,CAAV,CAAZ,CAA9B,CAEA,KAAI,CAACA,GAAD,CAAJ,CAAUxB,QAAV,CAAqB,KAAI,CAACwB,GAAD,CAAJ,CAAUxB,QAAV,EAAsB,KAA3C,CACD,CAJD,EAKD,CAED;AACF;AACA;AACA;AACA;AACA;AACA,K,oDACE,2BAAkBwB,GAAlB,CAAuB,CACrB,MAAOb,OAAM,CAACI,IAAP,CAAY,IAAZ,EAAkBU,QAAlB,CAA2BD,GAA3B,CAAP,CACD,CAED;AACF;AACA;AACA;AACA;AACA;AACA,K,8BACE,wBAAea,IAAf,CAAqB,CACnB,GAAIA,IAAI,CAAC9B,WAAL,GAAqBI,MAAzB,CAAiC,CAC/B,MAAQ,EAAE,QAAU0B,KAAZ,GAAqBA,IAAI,CAAC3C,IAAL,CAAUa,WAAV,GAA0BI,MAAvD,CACD,CACD,MAAQ,EAAE,QAAU,MAAK0B,IAAL,CAAZ,GAA2B,KAAKA,IAAL,EAAW3C,IAAX,CAAgBa,WAAhB,GAAgCI,MAAnE,CACD,CAED;AACF;AACA;AACA;AACA;AACA,K,4BACE,sBAAaa,GAAb,CAAkB,CAChB,MAAQ,MAAKc,iBAAL,CAAuBd,GAAvB,CAAD,kBAAqC,KAAKA,GAAL,CAArC,EAAmDe,SAA1D,CACD,CAED;AACF;AACA;AACA;AACA;AACA;AACA,K,0BACE,oBAAWF,IAAX,CAAiB,CACf,GAAIA,IAAI,CAAC9B,WAAL,GAAqBI,MAAzB,CAAiC,CAC/B,MAAQ,YAAc0B,KAAd,EAAsBA,IAAI,CAACnC,QAAnC,CACD,CAED,MAAO,MAAKmC,IAAL,EAAWnC,QAAlB,CACD,CAED;AACF;AACA;AACA;AACA;AACA;AACA,K,iCACE,2BAAkBmC,IAAlB,CAAwBG,IAAxB,CAA8BC,MAA9B,CAAsC,iBACpC,MAAO9B,OAAM,CAACI,IAAP,CAAYsB,IAAZ,EAAkBK,MAAlB,CAAyB,SAACC,GAAD,CAAMnB,GAAN,CAAc,CAC5C,GAAI,CAAC,UAAD,CAAa,UAAb,EAAyBC,QAAzB,CAAkCD,GAAlC,CAAJ,CAA4C,0BAAWmB,GAAX,EAE5C,GAAI,EAAE,QAAUN,KAAI,CAACb,GAAD,CAAhB,CAAJ,CAA4B,CAC1B,mCAAWmB,GAAX,qBAAmB,MAAI,CAACC,iBAAL,CAAuBP,IAAI,CAACb,GAAD,CAA3B,CAAkCgB,IAAlC,CAAwChB,GAAxC,CAAnB,GACD,CAED,GAAI,MAAI,CAACqB,UAAL,CAAgBR,IAAI,CAACb,GAAD,CAApB,CAAJ,CAAgC,mCAAWmB,GAAX,GAAiB,CAACF,MAAF,WAAeD,IAAf,aAAuBhB,GAAvB,YAAkCgB,IAAlC,aAA0CC,MAA1C,aAAoDjB,GAApD,CAAhB,GAEhC,0BAAWmB,GAAX,EACD,CAVM,CAUJ,EAVI,CAAP,CAWD,CAED;AACF;AACA;AACA;AACA,K,8BACE,yBAAiB,iBACf,MAAOhC,OAAM,CAACI,IAAP,CAAY,IAAZ,EACJ2B,MADI,CACG,SAACC,GAAD,CAAMnB,GAAN,CAAc,CACpB,GAAI,MAAI,CAACsB,cAAL,CAAoBtB,GAApB,CAAJ,CAA8B,CAC5B,mCAAWmB,GAAX,qBAAmB,MAAI,CAACC,iBAAL,CAAuB,MAAI,CAACpB,GAAD,CAA3B,CAAkCA,GAAlC,CAAnB,GACD,CAED,GAAI,MAAI,CAACqB,UAAL,CAAgBrB,GAAhB,CAAJ,CAA0B,CACxB,mCAAWmB,GAAX,GAAgBnB,GAAhB,GACD,CAED,0BAAWmB,GAAX,EACD,CAXI,CAWF,EAXE,CAAP,CAYD,CAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA,K,wBACE,kBAASN,IAAT,CAAe,CACb,GAAMI,OAAM,CAAG,KAAKK,cAAL,CAAoBT,IAApB,CAAf,CAEA,GAAIA,IAAI,CAAC9B,WAAL,GAAqBI,MAArB,EAA+B,CAAC8B,MAApC,CAA4C,CAC1C,MAAQ,SAAWJ,KAAZ,CAAoBA,IAAI,CAAClC,KAAzB,CAAiCoC,SAAxC,CACD,CAED,GAAIE,MAAJ,CAAY,CACV,KAAKM,QAAL,CAAcV,IAAd,EACD,CAED,MAAO,MAAKA,IAAL,EAAWlC,KAAlB,CACD,CAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA,G,+BACE,yBAAgBkC,IAAhB,CAAsBG,IAAtB,CAAgD,oBAApBC,OAAoB,2DAAXF,SAAW,CAC9C,MAAO5B,OAAM,CAACI,IAAP,CAAYsB,IAAZ,EAAkBK,MAAlB,CAAyB,SAACC,GAAD,CAAMnB,GAAN,CAAc,CAC5C,GAAI,CAAC,UAAD,CAAa,UAAb,EAAyBC,QAAzB,CAAkCD,GAAlC,CAAJ,CAA4C,wBAAYmB,GAAZ,EAE5C,GAAI,MAAI,CAACG,cAAL,CAAoBT,IAAI,CAACb,GAAD,CAAxB,CAAJ,CAAoC,CAClC,sCAAYmB,GAAZ,EAAoB,MAAI,CAACK,eAAL,CAAqBX,IAAI,CAACb,GAAD,CAAzB,CAAgCgB,IAAhC,CAAsChB,GAAtC,CAApB,EACD,CAED,GAAMrB,MAAK,CAAG,MAAI,CAAC4C,QAAL,CAAcV,IAAI,CAACb,GAAD,CAAlB,CAAd,CACA,GAAIrB,KAAJ,CAAW,CACT,sCAAYwC,GAAZ,wBAAmB,CAACF,MAAF,WAAeD,IAAf,aAAuBhB,GAAvB,YAAkCgB,IAAlC,aAA0CC,MAA1C,aAAoDjB,GAApD,CAAlB,CAA8ErB,KAA9E,GACD,CAED,wBAAYwC,GAAZ,EACD,CAbM,CAaJ,EAbI,CAAP,CAcD,CAED;AACF;AACA;AACA;AACA;AACA,K,4BACE,uBAAe,iBACb,MAAOhC,OAAM,CAACI,IAAP,CAAY,IAAZ,EAAkB2B,MAAlB,CAAyB,SAACC,GAAD,CAAMnB,GAAN,CAAc,CAC5C,GAAI,MAAI,CAACsB,cAAL,CAAoB,MAAI,CAACtB,GAAD,CAAxB,CAAJ,CAAoC,CAClC,GAAMiB,OAAM,kBAAQ,MAAI,CAACO,eAAL,CAAqB,MAAI,CAACxB,GAAD,CAAzB,CAAgCA,GAAhC,CAAR,CAAZ,CACA,MAAQiB,OAAD,gCAAgBE,GAAhB,EAAwBF,MAAxB,mBAAwCE,GAAxC,CAAP,CACD,CAED,GAAMxC,MAAK,CAAG,MAAI,CAAC4C,QAAL,CAAc,MAAI,CAACvB,GAAD,CAAlB,CAAd,CACA,GAAIrB,KAAJ,CAAW,CACT,sCAAYwC,GAAZ,wBAAkBnB,GAAlB,CAAwBrB,KAAxB,GACD,CAED,wBAAYwC,GAAZ,EACD,CAZM,CAYJ,EAZI,CAAP,CAaD,CAED;AACF;AACA;AACA;AACA;AACA,K,0BACE,oBAAWN,IAAX,CAAiB,CACf,GAAIA,IAAI,CAAC9B,WAAL,GAAqBI,MAAzB,CAAiC,CAC/B,MAAQ,YAAc0B,KAAf,CAAuBA,IAAI,CAACrC,QAA5B,CAAuC,KAA9C,CACD,CAED,MAAO,MAAKqC,IAAL,EAAWrC,QAAlB,CACD,CAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA,I,iCACE,2BAAkBqC,IAAlB,CAAwBG,IAAxB,CAAkD,oBAApBC,OAAoB,2DAAXF,SAAW,CAChD,MAAO5B,OAAM,CAACI,IAAP,CAAYsB,IAAZ,EAAkBK,MAAlB,CAAyB,SAACC,GAAD,CAAMnB,GAAN,CAAc,CAC5C,GAAI,CAAC,UAAD,CAAa,UAAb,EAAyBC,QAAzB,CAAkCD,GAAlC,CAAJ,CAA4C,0BAAWmB,GAAX,EAE5C,GAAI,MAAI,CAACG,cAAL,CAAoBT,IAAI,CAACb,GAAD,CAAxB,CAAJ,CAAoC,CAClC,mCAAWmB,GAAX,qBAAmB,MAAI,CAACM,iBAAL,CAAuBZ,IAAI,CAACb,GAAD,CAA3B,CAAkCgB,IAAlC,CAAwChB,GAAxC,CAAnB,GACD,CAED,GAAI,MAAI,CAAC0B,UAAL,CAAgBb,IAAI,CAACb,GAAD,CAApB,CAAJ,CAAgC,CAC9B,mCAAWmB,GAAX,GAAiB,CAACF,MAAF,WAAeD,IAAf,aAAuBhB,GAAvB,YAAkCgB,IAAlC,aAA0CC,MAA1C,aAAoDjB,GAApD,CAAhB,GACD,CAED,0BAAWmB,GAAX,EACD,CAZM,CAYJ,EAZI,CAAP,CAaD,CAED;AACF;AACA;AACA;AACA;AACA,K,8BACE,yBAAiB,iBACf,MAAOhC,OAAM,CAACI,IAAP,CAAY,IAAZ,EACJ2B,MADI,CACG,SAACC,GAAD,CAAMnB,GAAN,CAAc,CACpB,GAAI,MAAI,CAACsB,cAAL,CAAoBtB,GAApB,CAAJ,CAA8B,CAC5B,GAAMiB,OAAM,CAAG,MAAI,CAACQ,iBAAL,CAAuB,MAAI,CAACzB,GAAD,CAA3B,CAAkCA,GAAlC,CAAf,CAEA,GAAIiB,MAAM,CAACzB,MAAP,CAAgB,CAApB,CAAuB,mCAAW2B,GAAX,qBAAmBF,MAAnB,GACxB,CAED,GAAI,MAAI,CAACS,UAAL,CAAgB1B,GAAhB,CAAJ,CAA0B,CACxB,mCAAWmB,GAAX,GAAgBnB,GAAhB,GACD,CAED,0BAAWmB,GAAX,EACD,CAbI,CAaF,EAbE,CAAP,CAcD,CAED;AACF;AACA;AACA;AACA;AACA;AACA,K,uBACE,iBAAQN,IAAR,CAAc,CACZ,GAAIA,IAAI,CAAC9B,WAAL,GAAqBI,MAAzB,CAAiC,CAC/B,MAAQ,QAAU0B,KAAX,CAAmBA,IAAI,CAAC3C,IAAxB,CAA+B6C,SAAtC,CACD,CAED,MAAO,MAAKF,IAAL,EAAW3C,IAAlB,CACD,CAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA,I,8BACE,wBAAe2C,IAAf,CAAqBG,IAArB,CAA+C,oBAApBC,OAAoB,2DAAXF,SAAW,CAC7C,MAAO5B,OAAM,CAACI,IAAP,CAAYsB,IAAZ,EAAkBK,MAAlB,CAAyB,SAACC,GAAD,CAAMnB,GAAN,CAAc,CAC5C,GAAI,CAAC,UAAD,CAAa,UAAb,EAAyBC,QAAzB,CAAkCD,GAAlC,CAAJ,CAA4C,wBAAYmB,GAAZ,EAE5C,GAAI,MAAI,CAACG,cAAL,CAAoBT,IAAI,CAACb,GAAD,CAAxB,CAAJ,CAAoC,CAClC,sCAAYmB,GAAZ,EAAoB,MAAI,CAACQ,cAAL,CAAoBd,IAAI,CAACb,GAAD,CAAxB,CAA+BgB,IAA/B,CAAqChB,GAArC,CAApB,EACD,CAED,GAAM9B,KAAI,CAAG,MAAI,CAAC0D,OAAL,CAAaf,IAAI,CAACb,GAAD,CAAjB,CAAb,CACA,GAAI9B,IAAJ,CAAU,CACR,sCAAYiD,GAAZ,wBAAmB,CAACF,MAAF,WAAeD,IAAf,aAAuBhB,GAAvB,YAAkCgB,IAAlC,aAA0CC,MAA1C,aAAoDjB,GAApD,CAAlB,CAA8E9B,IAA9E,GACD,CAED,wBAAYiD,GAAZ,EACD,CAbM,CAaJ,EAbI,CAAP,CAcD,CAED;AACF;AACA;AACA;AACA;AACA,K,2BACE,sBAAc,iBACZ,MAAOhC,OAAM,CAACI,IAAP,CAAY,IAAZ,EAAkB2B,MAAlB,CAAyB,SAACC,GAAD,CAAMnB,GAAN,CAAc,CAC5C,GAAI,MAAI,CAACsB,cAAL,CAAoB,MAAI,CAACtB,GAAD,CAAxB,CAAJ,CAAoC,CAClC,GAAMiB,OAAM,kBAAQ,MAAI,CAACU,cAAL,CAAoB,MAAI,CAAC3B,GAAD,CAAxB,CAA+BA,GAA/B,CAAR,CAAZ,CACA,MAAQiB,OAAD,gCAAgBE,GAAhB,EAAwBF,MAAxB,mBAAwCE,GAAxC,CAAP,CACD,CAED,GAAMjD,KAAI,CAAG,MAAI,CAAC0D,OAAL,CAAa,MAAI,CAAC5B,GAAD,CAAjB,CAAb,CACA,GAAI9B,IAAJ,CAAU,CACR,sCAAYiD,GAAZ,wBAAkBnB,GAAlB,CAAwB9B,IAAxB,GACD,CAED,wBAAYiD,GAAZ,EACD,CAZM,CAYJ,EAZI,CAAP,CAaD,CAED;AACF;AACA;AACA;AACA;AACA;AACA,K,uBACE,iBAAQN,IAAR,CAAc,CACZ,GAAIA,IAAI,CAAC9B,WAAL,GAAqBI,MAAzB,CAAiC,CAC/B,MAAQ,QAAU0B,KAAlB,CACD,CAED,MAAQ,QAAU,MAAKA,IAAL,CAAlB,CACD,CAED;AACF;AACA;AACA;AACA;AACA;AACA,K,uBACE,iBAAQA,IAAR,CAAc,CACZ,GAAIA,IAAI,CAAC9B,WAAL,GAAqBI,MAAzB,CAAiC,CAC/B,MAAQ,MAAK0C,OAAL,CAAahB,IAAb,CAAD,oBAA2BA,IAAI,CAACpC,IAAhC,EAAwCsC,SAA/C,CACD,CAED,MAAQ,QAAU,MAAKF,IAAL,CAAX,oBAA6B,KAAKA,IAAL,EAAWpC,IAAxC,EAAgDsC,SAAvD,CACD,CAED;AACF;AACA;AACA;AACA;AACA,K,+BACE,0BAAkB,kBAChB,MAAO5B,OAAM,CAACI,IAAP,CAAY,IAAZ,EAAkB2B,MAAlB,CAAyB,SAACC,GAAD,CAAMnB,GAAN,CAAc,CAC5C,GAAI,OAAI,CAACA,GAAD,CAAJ,CAAUjB,WAAV,GAA0B+C,QAA9B,CAAwC,CACtC,sCAAYX,GAAZ,wBAAkBnB,GAAlB,CAAwB,OAAI,CAAC+B,YAAL,CAAkB/B,GAAlB,CAAxB,GACD,CAED,wBAAYmB,GAAZ,EACD,CANM,CAMJ,EANI,CAAP,CAOD,C,6BAvVkBvB,M"},"metadata":{},"sourceType":"module"}