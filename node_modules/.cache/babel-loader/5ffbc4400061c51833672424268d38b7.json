{"ast":null,"code":"// TODO: Refactor some code\nimport ERRORS from './errors';\n/**\n * Every valid options to create an Schema object\n */\n\nconst SCHEMA_OPTIONS = {\n  type: [Boolean, Date, Number, String, Array],\n  required: Boolean,\n  enum: [],\n  editable: Boolean,\n  label: String,\n  enumLabels: Array\n};\n/**\n * Check constructrors\n * @param {String} att\n * @param {constructor} type\n */\n\nconst checkConstructor = (att, type) => {\n  if (att.constructor !== type) {\n    throw ERRORS.not_valid_typo(att, type);\n  }\n};\n/**\n * Looks if the schema object is empty\n * @param {Object} [param]\n * @returns {Object}\n */\n\n\nconst checkParam = function () {\n  let param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  if (Object.prototype.toString.call(param) !== '[object Object]') {\n    throw ERRORS.not_valid_typo('Schema', 'Object', 'The Schema must be an Object');\n  }\n\n  if (Object.keys(param).length === 0) {\n    throw ERRORS.empty_object('Schema constructor cannot be empty');\n  }\n\n  return { ...param\n  };\n};\n/**\n * @param {Object} model\n * @param {Object} object\n * @returns {Object} santizied\n */\n\n\nconst checkSchema = function () {\n  let schema = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  /* eslint-disable-next-line */\n  if (schema.constructor === Schema) {\n    return { ...schema\n    };\n  }\n\n  if (Object.prototype.toString.call(schema) !== '[object Object]') {\n    throw ERRORS.not_valid_typo('Schema', 'Object');\n  }\n\n  if (Object.keys(schema).length === 0) {\n    throw ERRORS.empty_object('Schema object cannot be empty. At least must have \"type\" attribute');\n  }\n\n  if (!schema.type) throw ERRORS.att_required('type');\n  return { ...schema\n  };\n};\n/**\n * Check the delivered schema against his options\n * @param {object} schema\n * @returns [schema]\n */\n\n\nconst checkSchemaOptions = function () {\n  let schema = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  Object.keys(schema).forEach(key => {\n    /* eslint-disable-next-line */\n    if (schema[key].constructor === Schema || schema[key].constructor === Object && Object.keys(schema[key]).length > 0) {\n      return;\n    }\n    /* eslint-disable indent */\n\n\n    switch (key) {\n      case 'type':\n        if (!SCHEMA_OPTIONS[key].includes(schema[key])) {\n          const value = schema[key].toString().match(/[A-Z][a-z]+/g)[0];\n          const arr = SCHEMA_OPTIONS[key].map(type => type.toString().match(/[A-Z][a-z]+/g)[0]);\n          throw ERRORS.not_in_enum(key, value, arr);\n        }\n\n        break;\n\n      case 'required':\n        checkConstructor(schema[key], SCHEMA_OPTIONS[key]);\n        break;\n\n      case 'label':\n        checkConstructor(schema[key], SCHEMA_OPTIONS[key]);\n        break;\n\n      case 'editable':\n        checkConstructor(schema[key], SCHEMA_OPTIONS[key]);\n        break;\n\n      case 'enum':\n        if (!Array.isArray(schema[key])) throw ERRORS.not_valid_typo(schema[key], Array);\n        schema[key].forEach(element => {\n          if (element.constructor !== schema.type) {\n            const msg = `${element.constructor.toString().match(/[A-Z][a-z]+/g)[0]} given, must be ${schema.type.toString().match(/[A-Z][a-z]+/g)[0]}`;\n            throw ERRORS.not_valid_typo(element, schema.type, msg);\n          }\n        });\n        break;\n\n      case 'enumLabels':\n        checkConstructor(schema[key], SCHEMA_OPTIONS[key]);\n        break;\n\n      /* eslint-enable indent */\n\n      /* eslint-disable  */\n\n      default:\n        if (schema[key].constructor !== Object && !schema[key].type) {\n          throw ERRORS.att_not_valid(key, `${key} is not a valid options for Schema Object`);\n        }\n\n        let nestedObject = { ...schema[key]\n        };\n        nestedObject = checkSchemaOptions(checkSchema(nestedObject));\n        schema[key] = { ...nestedObject\n        };\n        break;\n\n      /* eslint-enable */\n    }\n  });\n  return { ...schema\n  };\n};\n/**\n * Manage an Schema to validate every Model instance\n * @class Schema\n */\n\n/* eslint-disable class-methods-use-this */\n\n\nexport default class Schema {\n  /**\n   * Creates an instance of Schema.\n   * @param {Object} [schema]\n   * @memberof Schema\n   */\n  constructor() {\n    let schema = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const sanitized = checkParam(schema);\n    Object.keys(sanitized).forEach(key => {\n      this[key] = checkSchemaOptions(checkSchema(sanitized[key]));\n      this[key].required = this[key].required || false;\n    });\n  }\n  /**\n   * Returns true if the given key are in\n   * the Schema\n   * @param {String} key\n   * @returns Boolean\n   * @memberof Schema\n   */\n\n\n  attributeInSchema(key) {\n    return Object.keys(this).includes(key);\n  }\n  /**\n   * Return true if the Schema attribute is\n   * a nested object\n   * @param {Any} attr Could be a String or an Object\n   * @returns Boolean\n   * @memberof Schema\n   */\n\n\n  isNestedSchema(attr) {\n    if (attr.constructor === Object) {\n      return !('type' in attr) || attr.type.constructor === Object;\n    }\n\n    return !('type' in this[attr]) || this[attr].type.constructor === Object;\n  }\n  /**\n   * Return all the options of the given entry\n   * @param {any} key\n   * @returns Object\n   * @memberof Schema\n   */\n\n\n  getAttribute(key) {\n    return this.attributeInSchema(key) ? { ...this[key]\n    } : undefined;\n  }\n  /**\n   * Returns the value of required option in\n   * attribute\n   * @param {Any} attr Attribute to look for required option. Could be String or Object\n   * @returns Boolean\n   * @memberof Schema\n   */\n\n\n  isEditable(attr) {\n    if (attr.constructor === Object) {\n      return 'editable' in attr && attr.editable;\n    }\n\n    return this[attr].editable;\n  }\n  /**\n   * Get all nested attributes who are editable\n   * @param {Object} attr Object to extract the values\n   * @param {String} name Name(key) of the Object\n   * @returns Array\n   * @memberof Schema\n   */\n\n\n  getNestedEditable(attr, name, nested) {\n    return Object.keys(attr).reduce((acc, key) => {\n      if (['required', 'editable'].includes(key)) return [...acc];\n\n      if (!('type' in attr[key])) {\n        return [...acc, ...this.getNestedEditable(attr[key], name, key)];\n      }\n\n      if (this.isEditable(attr[key])) return [...acc, !nested ? `${name}.${key}` : `${name}.${nested}.${key}`];\n      return [...acc];\n    }, []);\n  }\n  /**\n   * Get all attributes that can be edited\n   * @returns Array\n   * @memberof Schema\n   */\n\n\n  getAllEditable() {\n    return Object.keys(this).reduce((acc, key) => {\n      if (this.isNestedSchema(key)) {\n        return [...acc, ...this.getNestedEditable(this[key], key)];\n      }\n\n      if (this.isEditable(key)) {\n        return [...acc, key];\n      }\n\n      return [...acc];\n    }, []);\n  }\n  /**\n   * Get label for the given object\n   * If the attribute doesn't have a label\n   * it return false;\n   * @param {Any} attr Attribute to look for required option. Could be String or Object\n   * @returns String or Boolean\n   * @memberof Schema\n   */\n\n\n  getLabel(attr) {\n    const nested = this.isNestedSchema(attr);\n\n    if (attr.constructor === Object && !nested) {\n      return 'label' in attr ? attr.label : undefined;\n    }\n\n    if (nested) {\n      this.getLabel(attr);\n    }\n\n    return this[attr].label;\n  }\n  /**\n  * Get all nested labels an returns as an Object\n  * @param {Object} attr Object to extract the labels\n  * @param {String} name Name(key) of the Object\n  * @param {String} nested Second key to go through second layer of the object\n  * @returns Object\n  * @memberof Schema\n  */\n\n\n  getNestedLabels(attr, name) {\n    let nested = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n    return Object.keys(attr).reduce((acc, key) => {\n      if (['required', 'editable'].includes(key)) return { ...acc\n      };\n\n      if (this.isNestedSchema(attr[key])) {\n        return { ...acc,\n          ...this.getNestedLabels(attr[key], name, key)\n        };\n      }\n\n      const label = this.getLabel(attr[key]);\n\n      if (label) {\n        return { ...acc,\n          [!nested ? `${name}.${key}` : `${name}.${nested}.${key}`]: label\n        };\n      }\n\n      return { ...acc\n      };\n    }, {});\n  }\n  /**\n   * Get all labels from the attributes in the\n   * Schema\n   * @returns Object\n   * @memberof Schema\n   */\n\n\n  getAllLabels() {\n    return Object.keys(this).reduce((acc, key) => {\n      if (this.isNestedSchema(this[key])) {\n        const nested = { ...this.getNestedLabels(this[key], key)\n        };\n        return nested ? { ...acc,\n          ...nested\n        } : { ...acc\n        };\n      }\n\n      const label = this.getLabel(this[key]);\n\n      if (label) {\n        return { ...acc,\n          [key]: label\n        };\n      }\n\n      return { ...acc\n      };\n    }, {});\n  }\n  /**\n   * Returns the value in required option\n   * @param {Object} attr Could be Object or String\n   * @returns Boolean\n   * @memberof Schema\n   */\n\n\n  isRequired(attr) {\n    if (attr.constructor === Object) {\n      return 'required' in attr ? attr.required : false;\n    }\n\n    return this[attr].required;\n  }\n  /**\n  * Get all nested required an returns as an Array\n  * @param {Object} attr Object to extract the labels\n  * @param {String} name Name(key) of the Object\n  * @param {String} nested Second key to go through second layer of the object\n  * @returns Array\n  * @memberof Schema\n  */\n\n\n  getNestedRequired(attr, name) {\n    let nested = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n    return Object.keys(attr).reduce((acc, key) => {\n      if (['required', 'editable'].includes(key)) return [...acc];\n\n      if (this.isNestedSchema(attr[key])) {\n        return [...acc, ...this.getNestedRequired(attr[key], name, key)];\n      }\n\n      if (this.isRequired(attr[key])) {\n        return [...acc, !nested ? `${name}.${key}` : `${name}.${nested}.${key}`];\n      }\n\n      return [...acc];\n    }, []);\n  }\n  /**\n   * Returns all the attributes that required\n   * are true. If no there's not, return an Empty Array\n   * @returns Array\n   * @memberof Schema\n   */\n\n\n  getAllRequired() {\n    return Object.keys(this).reduce((acc, key) => {\n      if (this.isNestedSchema(key)) {\n        const nested = this.getNestedRequired(this[key], key);\n        if (nested.length > 0) return [...acc, ...nested];\n      }\n\n      if (this.isRequired(key)) {\n        return [...acc, key];\n      }\n\n      return [...acc];\n    }, []);\n  }\n  /**\n   * Get the type of an attribute\n   * If invalid attribute, it returns undefined\n   * @param {any} attr Could be String or an Object\n   * @returns Constructor\n   * @memberof Schema\n   */\n\n\n  getType(attr) {\n    if (attr.constructor === Object) {\n      return 'type' in attr ? attr.type : undefined;\n    }\n\n    return this[attr].type;\n  }\n  /**\n  * Get all nested types and returns as an Object\n  * @param {Object} attr Object to extract the labels\n  * @param {String} name Name(key) of the Object\n  * @param {String} nested Second key to go through second layer of the object\n  * @returns Object\n  * @memberof Schema\n  */\n\n\n  getNestedTypes(attr, name) {\n    let nested = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n    return Object.keys(attr).reduce((acc, key) => {\n      if (['required', 'editable'].includes(key)) return { ...acc\n      };\n\n      if (this.isNestedSchema(attr[key])) {\n        return { ...acc,\n          ...this.getNestedTypes(attr[key], name, key)\n        };\n      }\n\n      const type = this.getType(attr[key]);\n\n      if (type) {\n        return { ...acc,\n          [!nested ? `${name}.${key}` : `${name}.${nested}.${key}`]: type\n        };\n      }\n\n      return { ...acc\n      };\n    }, {});\n  }\n  /**\n   * Returns an Object with key/value for\n   * each attribute and his type value.\n   * @returns Object\n   * @memberof Schema\n   */\n\n\n  getAllTypes() {\n    return Object.keys(this).reduce((acc, key) => {\n      if (this.isNestedSchema(this[key])) {\n        const nested = { ...this.getNestedTypes(this[key], key)\n        };\n        return nested ? { ...acc,\n          ...nested\n        } : { ...acc\n        };\n      }\n\n      const type = this.getType(this[key]);\n\n      if (type) {\n        return { ...acc,\n          [key]: type\n        };\n      }\n\n      return { ...acc\n      };\n    }, {});\n  }\n  /**\n   * Returns true if the attribute has an enum option\n   * defined\n   * @param {Any} attr Could be String or Object\n   * @returns Boolean\n   * @memberof Schema\n   */\n\n\n  hasEnum(attr) {\n    if (attr.constructor === Object) {\n      return 'enum' in attr;\n    }\n\n    return 'enum' in this[attr];\n  }\n  /**\n   * Return the specified enum option of the\n   * attribute given. If doesnt have, return undefined\n   * @param {Any} attr Could be String or Object\n   * @returns Array or Undefined\n   * @memberof Schema\n   */\n\n\n  getEnum(attr) {\n    if (attr.constructor === Object) {\n      return this.hasEnum(attr) ? [...attr.enum] : undefined;\n    }\n\n    return 'enum' in this[attr] ? [...this[attr].enum] : undefined;\n  }\n  /**\n   * Return an object with all attributes an options.\n   * Functions are ignored;\n   * @returns Object\n   * @memberof Schema\n   */\n\n\n  getAllAtributes() {\n    return Object.keys(this).reduce((acc, key) => {\n      if (this[key].constructor !== Function) {\n        return { ...acc,\n          [key]: this.getAttribute(key)\n        };\n      }\n\n      return { ...acc\n      };\n    }, {});\n  }\n\n}","map":{"version":3,"names":["ERRORS","SCHEMA_OPTIONS","type","Boolean","Date","Number","String","Array","required","enum","editable","label","enumLabels","checkConstructor","att","constructor","not_valid_typo","checkParam","param","Object","prototype","toString","call","keys","length","empty_object","checkSchema","schema","Schema","att_required","checkSchemaOptions","forEach","key","includes","value","match","arr","map","not_in_enum","isArray","element","msg","att_not_valid","nestedObject","sanitized","attributeInSchema","isNestedSchema","attr","getAttribute","undefined","isEditable","getNestedEditable","name","nested","reduce","acc","getAllEditable","getLabel","getNestedLabels","getAllLabels","isRequired","getNestedRequired","getAllRequired","getType","getNestedTypes","getAllTypes","hasEnum","getEnum","getAllAtributes","Function"],"sources":["/Users/mac/Desktop/sky/skyalert-New/src/utils/schema.js"],"sourcesContent":["// TODO: Refactor some code\n\nimport ERRORS from './errors';\n\n/**\n * Every valid options to create an Schema object\n */\nconst SCHEMA_OPTIONS = {\n  type: [Boolean, Date, Number, String, Array],\n  required: Boolean,\n  enum: [],\n  editable: Boolean,\n  label: String,\n  enumLabels: Array,\n};\n\n/**\n * Check constructrors\n * @param {String} att\n * @param {constructor} type\n */\nconst checkConstructor = (att, type) => {\n  if (att.constructor !== type) {\n    throw ERRORS.not_valid_typo(att, type);\n  }\n};\n\n/**\n * Looks if the schema object is empty\n * @param {Object} [param]\n * @returns {Object}\n */\nconst checkParam = (param = {}) => {\n  if (Object.prototype.toString.call(param) !== '[object Object]') {\n    throw ERRORS.not_valid_typo('Schema', 'Object', 'The Schema must be an Object');\n  }\n\n  if (Object.keys(param).length === 0) {\n    throw ERRORS.empty_object('Schema constructor cannot be empty');\n  }\n\n  return { ...param };\n};\n\n/**\n * @param {Object} model\n * @param {Object} object\n * @returns {Object} santizied\n */\nconst checkSchema = (schema = {}) => {\n  /* eslint-disable-next-line */\n  if (schema.constructor === Schema) {\n    return { ...schema };\n  }\n\n  if (Object.prototype.toString.call(schema) !== '[object Object]') {\n    throw ERRORS.not_valid_typo('Schema', 'Object');\n  }\n\n  if (Object.keys(schema).length === 0) {\n    throw ERRORS.empty_object('Schema object cannot be empty. At least must have \"type\" attribute');\n  }\n\n  if (!schema.type) throw ERRORS.att_required('type');\n\n  return { ...schema };\n};\n\n/**\n * Check the delivered schema against his options\n * @param {object} schema\n * @returns [schema]\n */\nconst checkSchemaOptions = (schema = {}) => {\n  Object.keys(schema).forEach((key) => {\n    /* eslint-disable-next-line */\n    if (schema[key].constructor === Schema || (schema[key].constructor === Object\n      && Object.keys(schema[key]).length > 0)) {\n      return;\n    }\n\n    /* eslint-disable indent */\n    switch (key) {\n      case 'type':\n        if (!SCHEMA_OPTIONS[key].includes(schema[key])) {\n          const value = schema[key].toString().match(/[A-Z][a-z]+/g)[0];\n          const arr = SCHEMA_OPTIONS[key].map(type => type.toString().match(/[A-Z][a-z]+/g)[0]);\n\n          throw ERRORS.not_in_enum(key, value, arr);\n        }\n        break;\n\n      case 'required':\n        checkConstructor(schema[key], SCHEMA_OPTIONS[key]);\n        break;\n\n      case 'label':\n        checkConstructor(schema[key], SCHEMA_OPTIONS[key]);\n        break;\n\n      case 'editable':\n        checkConstructor(schema[key], SCHEMA_OPTIONS[key]);\n        break;\n\n      case 'enum':\n        if (!Array.isArray(schema[key])) throw ERRORS.not_valid_typo(schema[key], Array);\n\n        schema[key].forEach((element) => {\n          if (element.constructor !== schema.type) {\n            const msg = `${element.constructor.toString().match(/[A-Z][a-z]+/g)[0]} given, must be ${schema.type.toString().match(/[A-Z][a-z]+/g)[0]}`;\n            throw ERRORS.not_valid_typo(element, schema.type, msg);\n          }\n        });\n        break;\n\n      case 'enumLabels':\n        checkConstructor(schema[key], SCHEMA_OPTIONS[key]);\n        break;\n      /* eslint-enable indent */\n\n      /* eslint-disable  */\n      default:\n\n        if (schema[key].constructor !== Object && !schema[key].type) {\n          throw ERRORS.att_not_valid(key, `${key} is not a valid options for Schema Object`);\n        }\n\n        let nestedObject = { ...schema[key] };\n\n        nestedObject = checkSchemaOptions(checkSchema(nestedObject));\n\n        schema[key] = { ...nestedObject };\n        break;\n      /* eslint-enable */\n    }\n  });\n\n  return { ...schema };\n};\n\n\n/**\n * Manage an Schema to validate every Model instance\n * @class Schema\n */\n/* eslint-disable class-methods-use-this */\nexport default class Schema {\n  /**\n   * Creates an instance of Schema.\n   * @param {Object} [schema]\n   * @memberof Schema\n   */\n  constructor(schema = {}) {\n    const sanitized = checkParam(schema);\n\n    Object.keys(sanitized).forEach((key) => {\n      this[key] = checkSchemaOptions(checkSchema(sanitized[key]));\n\n      this[key].required = this[key].required || false;\n    });\n  }\n\n  /**\n   * Returns true if the given key are in\n   * the Schema\n   * @param {String} key\n   * @returns Boolean\n   * @memberof Schema\n   */\n  attributeInSchema(key) {\n    return Object.keys(this).includes(key);\n  }\n\n  /**\n   * Return true if the Schema attribute is\n   * a nested object\n   * @param {Any} attr Could be a String or an Object\n   * @returns Boolean\n   * @memberof Schema\n   */\n  isNestedSchema(attr) {\n    if (attr.constructor === Object) {\n      return (!('type' in attr) || attr.type.constructor === Object);\n    }\n    return (!('type' in this[attr]) || this[attr].type.constructor === Object);\n  }\n\n  /**\n   * Return all the options of the given entry\n   * @param {any} key\n   * @returns Object\n   * @memberof Schema\n   */\n  getAttribute(key) {\n    return (this.attributeInSchema(key)) ? { ...this[key] } : undefined;\n  }\n\n  /**\n   * Returns the value of required option in\n   * attribute\n   * @param {Any} attr Attribute to look for required option. Could be String or Object\n   * @returns Boolean\n   * @memberof Schema\n   */\n  isEditable(attr) {\n    if (attr.constructor === Object) {\n      return ('editable' in attr && attr.editable);\n    }\n\n    return this[attr].editable;\n  }\n\n  /**\n   * Get all nested attributes who are editable\n   * @param {Object} attr Object to extract the values\n   * @param {String} name Name(key) of the Object\n   * @returns Array\n   * @memberof Schema\n   */\n  getNestedEditable(attr, name, nested) {\n    return Object.keys(attr).reduce((acc, key) => {\n      if (['required', 'editable'].includes(key)) return [...acc];\n\n      if (!('type' in attr[key])) {\n        return [...acc, ...this.getNestedEditable(attr[key], name, key)];\n      }\n\n      if (this.isEditable(attr[key])) return [...acc, (!nested) ? `${name}.${key}` : `${name}.${nested}.${key}`];\n\n      return [...acc];\n    }, []);\n  }\n\n  /**\n   * Get all attributes that can be edited\n   * @returns Array\n   * @memberof Schema\n   */\n  getAllEditable() {\n    return Object.keys(this)\n      .reduce((acc, key) => {\n        if (this.isNestedSchema(key)) {\n          return [...acc, ...this.getNestedEditable(this[key], key)];\n        }\n\n        if (this.isEditable(key)) {\n          return [...acc, key];\n        }\n\n        return [...acc];\n      }, []);\n  }\n\n  /**\n   * Get label for the given object\n   * If the attribute doesn't have a label\n   * it return false;\n   * @param {Any} attr Attribute to look for required option. Could be String or Object\n   * @returns String or Boolean\n   * @memberof Schema\n   */\n  getLabel(attr) {\n    const nested = this.isNestedSchema(attr);\n\n    if (attr.constructor === Object && !nested) {\n      return ('label' in attr) ? attr.label : undefined;\n    }\n\n    if (nested) {\n      this.getLabel(attr);\n    }\n\n    return this[attr].label;\n  }\n\n  /**\n * Get all nested labels an returns as an Object\n * @param {Object} attr Object to extract the labels\n * @param {String} name Name(key) of the Object\n * @param {String} nested Second key to go through second layer of the object\n * @returns Object\n * @memberof Schema\n */\n  getNestedLabels(attr, name, nested = undefined) {\n    return Object.keys(attr).reduce((acc, key) => {\n      if (['required', 'editable'].includes(key)) return { ...acc };\n\n      if (this.isNestedSchema(attr[key])) {\n        return { ...acc, ...this.getNestedLabels(attr[key], name, key) };\n      }\n\n      const label = this.getLabel(attr[key]);\n      if (label) {\n        return { ...acc, [(!nested) ? `${name}.${key}` : `${name}.${nested}.${key}`]: label };\n      }\n\n      return { ...acc };\n    }, {});\n  }\n\n  /**\n   * Get all labels from the attributes in the\n   * Schema\n   * @returns Object\n   * @memberof Schema\n   */\n  getAllLabels() {\n    return Object.keys(this).reduce((acc, key) => {\n      if (this.isNestedSchema(this[key])) {\n        const nested = { ...this.getNestedLabels(this[key], key) };\n        return (nested) ? { ...acc, ...nested } : { ...acc };\n      }\n\n      const label = this.getLabel(this[key]);\n      if (label) {\n        return { ...acc, [key]: label };\n      }\n\n      return { ...acc };\n    }, {});\n  }\n\n  /**\n   * Returns the value in required option\n   * @param {Object} attr Could be Object or String\n   * @returns Boolean\n   * @memberof Schema\n   */\n  isRequired(attr) {\n    if (attr.constructor === Object) {\n      return ('required' in attr) ? attr.required : false;\n    }\n\n    return this[attr].required;\n  }\n\n  /**\n  * Get all nested required an returns as an Array\n  * @param {Object} attr Object to extract the labels\n  * @param {String} name Name(key) of the Object\n  * @param {String} nested Second key to go through second layer of the object\n  * @returns Array\n  * @memberof Schema\n  */\n  getNestedRequired(attr, name, nested = undefined) {\n    return Object.keys(attr).reduce((acc, key) => {\n      if (['required', 'editable'].includes(key)) return [...acc];\n\n      if (this.isNestedSchema(attr[key])) {\n        return [...acc, ...this.getNestedRequired(attr[key], name, key)];\n      }\n\n      if (this.isRequired(attr[key])) {\n        return [...acc, (!nested) ? `${name}.${key}` : `${name}.${nested}.${key}`];\n      }\n\n      return [...acc];\n    }, []);\n  }\n\n  /**\n   * Returns all the attributes that required\n   * are true. If no there's not, return an Empty Array\n   * @returns Array\n   * @memberof Schema\n   */\n  getAllRequired() {\n    return Object.keys(this)\n      .reduce((acc, key) => {\n        if (this.isNestedSchema(key)) {\n          const nested = this.getNestedRequired(this[key], key);\n\n          if (nested.length > 0) return [...acc, ...nested];\n        }\n\n        if (this.isRequired(key)) {\n          return [...acc, key];\n        }\n\n        return [...acc];\n      }, []);\n  }\n\n  /**\n   * Get the type of an attribute\n   * If invalid attribute, it returns undefined\n   * @param {any} attr Could be String or an Object\n   * @returns Constructor\n   * @memberof Schema\n   */\n  getType(attr) {\n    if (attr.constructor === Object) {\n      return ('type' in attr) ? attr.type : undefined;\n    }\n\n    return this[attr].type;\n  }\n\n  /**\n  * Get all nested types and returns as an Object\n  * @param {Object} attr Object to extract the labels\n  * @param {String} name Name(key) of the Object\n  * @param {String} nested Second key to go through second layer of the object\n  * @returns Object\n  * @memberof Schema\n  */\n  getNestedTypes(attr, name, nested = undefined) {\n    return Object.keys(attr).reduce((acc, key) => {\n      if (['required', 'editable'].includes(key)) return { ...acc };\n\n      if (this.isNestedSchema(attr[key])) {\n        return { ...acc, ...this.getNestedTypes(attr[key], name, key) };\n      }\n\n      const type = this.getType(attr[key]);\n      if (type) {\n        return { ...acc, [(!nested) ? `${name}.${key}` : `${name}.${nested}.${key}`]: type };\n      }\n\n      return { ...acc };\n    }, {});\n  }\n\n  /**\n   * Returns an Object with key/value for\n   * each attribute and his type value.\n   * @returns Object\n   * @memberof Schema\n   */\n  getAllTypes() {\n    return Object.keys(this).reduce((acc, key) => {\n      if (this.isNestedSchema(this[key])) {\n        const nested = { ...this.getNestedTypes(this[key], key) };\n        return (nested) ? { ...acc, ...nested } : { ...acc };\n      }\n\n      const type = this.getType(this[key]);\n      if (type) {\n        return { ...acc, [key]: type };\n      }\n\n      return { ...acc };\n    }, {});\n  }\n\n  /**\n   * Returns true if the attribute has an enum option\n   * defined\n   * @param {Any} attr Could be String or Object\n   * @returns Boolean\n   * @memberof Schema\n   */\n  hasEnum(attr) {\n    if (attr.constructor === Object) {\n      return ('enum' in attr);\n    }\n\n    return ('enum' in this[attr]);\n  }\n\n  /**\n   * Return the specified enum option of the\n   * attribute given. If doesnt have, return undefined\n   * @param {Any} attr Could be String or Object\n   * @returns Array or Undefined\n   * @memberof Schema\n   */\n  getEnum(attr) {\n    if (attr.constructor === Object) {\n      return (this.hasEnum(attr)) ? [...attr.enum] : undefined;\n    }\n\n    return ('enum' in this[attr]) ? [...this[attr].enum] : undefined;\n  }\n\n  /**\n   * Return an object with all attributes an options.\n   * Functions are ignored;\n   * @returns Object\n   * @memberof Schema\n   */\n  getAllAtributes() {\n    return Object.keys(this).reduce((acc, key) => {\n      if (this[key].constructor !== Function) {\n        return { ...acc, [key]: this.getAttribute(key) };\n      }\n\n      return { ...acc };\n    }, {});\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}